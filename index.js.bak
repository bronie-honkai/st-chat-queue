import { event_types, eventSource, selectRightMenuWithAnimation, doNavbarIconClick, getRequestHeaders, sendTextareaMessage, getCurrentMessage } from '../../../script.js';
import { getBase64Async, getFileExtension } from '../../utils.js';

/** @typedef {{ id: string; file: File; status: 'pending' | 'sending' | 'done' | 'error'; error?: string }} QueueItem */

let queue = /** @type {QueueItem[]} */ ([]);
let isRunning = false;
let currentIndex = 0;

// 当前拖拽源的队列项 id
let dragSourceId = null;

const RIGHT_MENU_ID = 'attachment_queue_block';

function updateStatusText() {
    const $status = $('#attachment_queue_status');
    if (!$status.length) return;

    if (queue.length === 0) {
        $status.text('队列为空');
        return;
    }

    if (!isRunning) {
        $status.text(`已添加 ${queue.length} 个文件，队列已暂停`);
        return;
    }

    $status.text(`正在处理第 ${currentIndex + 1} / ${queue.length} 个文件...`);
}

function renderQueueList() {
    const $list = $('#attachment_queue_list');
    if (!$list.length) return;

    $list.empty();

    for (const item of queue) {
        const $row = $('<div class="attachment-queue-item flex-container flexGap5" />');

        // 允许拖拽排序
        $row.attr('draggable', 'true');
        $row.attr('data-id', item.id);

        // 根据文件状态设置颜色
        let statusColor = '';
        if (item.status === 'done') statusColor = 'color: var(--SmartThemeSuccessColor, #3fb950);';
        if (item.status === 'error') statusColor = 'color: var(--SmartThemeErrorColor, #ff4d4f);';
        if (item.status === 'sending') statusColor = 'color: var(--SmartThemeAccentColor, #f5a623);';

        const iconClass = item.file.type.startsWith('image/')
            ? 'fa-regular fa-image'
            : item.file.type === 'application/pdf'
                ? 'fa-regular fa-file-pdf'
                : 'fa-regular fa-file-lines';

        const $dragHandle = $('<i class="fa-solid fa-grip-lines attachment-queue-drag-handle" />');
        const $icon = $('<i />').addClass(iconClass + ' attachment-queue-item-icon');
        const $name = $('<span class="attachment-queue-item-name" />').text(item.file.name);
        const $status = $('<span class="attachment-queue-item-status" style="' + statusColor + '"/>').text(translateStatus(item.status));

        if (item.status === 'error' && item.error) {
            $status.attr('title', item.error);
        }

        const $remove = $('<button type="button" class="attachment-queue-item-remove fa-solid fa-xmark" />');
        $remove.on('click', (e) => {
            e.stopPropagation();
            queue = queue.filter(q => q.id !== item.id);
            if (currentIndex >= queue.length) {
                currentIndex = Math.max(0, queue.length - 1);
            }
            renderQueueList();
            updateStatusText();
            updateSmartControlsVisibility();
        });

        bindDragAndDropEvents($row, item.id);

        $row.on('click', () => showPreviewForItem(item));

        $row.append($dragHandle, $icon, $name, $status, $remove);
        $list.append($row);
    }

    updateStatusText();
}

let currentPreviewUrl = null;

function showPreviewForItem(item) {
    const $preview = $('#attachment_queue_preview');
    if (!$preview.length) return;

    $preview.empty();

    const file = item.file;

    // 清理旧的 object URL
    if (currentPreviewUrl) {
        URL.revokeObjectURL(currentPreviewUrl);
        currentPreviewUrl = null;
    }

    if (file.type.startsWith('image/')) {
        const url = URL.createObjectURL(file);
        currentPreviewUrl = url;
        const $img = $('<img class="attachment-queue-preview-image" />');
        $img.attr('src', url);
        $img.attr('alt', file.name);
        $preview.append($img);
    } else if (file.type.startsWith('text/') || file.type === 'application/json') {
        const reader = new FileReader();
        reader.onload = () => {
            const text = String(reader.result || '').slice(0, 4000);
            const $pre = $('<pre class="attachment-queue-preview-text" />').text(text);
            $preview.append($pre);
        };
        reader.readAsText(file);
    } else {
        const $info = $('<div class="attachment-queue-preview-generic" />')
            .text(`${file.name} (${Math.round(file.size / 1024)} KB)`);
        $preview.append($info);
    }
}

function translateStatus(status) {
    const map = {
        'pending': '等待中',
        'sending': '发送中',
        'done': '完成',
        'error': '失败'
    };
    return map[status] || status;
}

/**
 * 将文件加入队列
 */
function addFilesToQueue(files) {
    const items = Array.from(files || []);
    if (!items.length) return;
    const now = Date.now();
    for (let i = 0; i < items.length; i++) {
        const file = items[i];
        const id = `${now}-${i}-${file.name}`;
        queue.push({ id, file, status: 'pending' });
    }
    renderQueueList();
    updateSmartControlsVisibility();
}

/**
 * 核心：上传并发送单个文件
 * 模拟原生“附加文件”逻辑：把文件塞回 #file_form_input，让 ST 自己上传并生成附件消息
 */
async function uploadAndSend(item) {
    const fileInput = document.getElementById('file_form_input');
    if (!(fileInput instanceof HTMLInputElement)) {
        throw new Error('file_form_input not found');
    }

    // 清空全局挂载队列，避免旧附件混入
    window.uploadResult = [];

    // 用 DataTransfer 模拟用户选择文件（与原生 handleFileAttach 同步）
    const dt = new DataTransfer();
    dt.items.add(item.file);
    fileInput.files = dt.files;

    // 触发原生 change 事件，交给 ST 内部逻辑上传并挂载附件
    $('#file_form_input').trigger('change');

    // 等待 ST 完成上传并把路径写入 window.uploadResult
    const start = Date.now();
    let path = '';
    while (Date.now() - start < 10000) { // 最多等 10s
        if (Array.isArray(window.uploadResult) && window.uploadResult.length > 0) {
            path = String(window.uploadResult[0]);
            break;
        }
        // eslint-disable-next-line no-await-in-loop
        await new Promise(r => setTimeout(r, 100));
    }

    if (!path) {
        throw new Error('Attachment not mounted (uploadResult empty after wait)');
    }

    console.log('[Attachment Queue] File mounted at:', path);

    // 唤醒 ST 的发送按钮状态：触发输入框的 input 事件让 ST 重新评估按钮状态
    const $textarea = $('#send_textarea');
    if ($textarea.length) {
        $textarea.trigger('input');
        $textarea.trigger('change');
    }

    // 等待一个短延时，确保 UI 状态已更新
    await new Promise(r => setTimeout(r, 150));

    // 获取发送按钮
    const $sendBtn = $('#send_but');
    if (!$sendBtn.length) {
        throw new Error('Send button not found');
    }

    // 尝试触发按钮的 mouseenter 事件唤醒状态
    $sendBtn.trigger('mouseenter');

    // 使用原生 DOM 点击而不仅仅是 jQuery trigger
    const sendBtnElem = document.getElementById('send_but');
    if (!sendBtnElem) {
        throw new Error('Send button DOM element not found');
    }

    // 第一次尝试点击
    sendBtnElem.click();

    // 等待一个短延时
    await new Promise(r => setTimeout(r, 200));

    // 延时重试：如果按钮仍被禁用，再点一次
    if (sendBtnElem.hasAttribute('disabled') || $sendBtn.hasClass('disabled')) {
        console.log('[Attachment Queue] Send button still disabled, retrying...');
        sendBtnElem.click();
        await new Promise(r => setTimeout(r, 200));
    }
}

/**
 * 直接上传文件到服务器
 * @param {File} file
 * @returns {Promise<string>} 返回文件路径
 */
async function directUploadFile(file) {
    try {
        // 将文件转换为 base64
        const base64Data = await getBase64Async(file);
        const base64Content = base64Data.split(',')[1];
        const extension = getFileExtension(file);
        const slug = getStringHash(file.name);
        const fileNamePrefix = `${Date.now()}_${slug}`;
        const uniqueFileName = `${fileNamePrefix}.${extension}`;

        console.log('[Attachment Queue] Uploading file:', uniqueFileName);

        // 上传到服务器
        const response = await fetch('/api/files/upload', {
            method: 'POST',
            headers: getRequestHeaders(),
            body: JSON.stringify({
                name: uniqueFileName,
                data: base64Content,
            }),
        });

        if (!response.ok) {
            const error = await response.text();
            throw new Error(`Upload error: ${error}`);
        }

        const responseData = await response.json();
        const filePath = responseData.path;

        if (!filePath) {
            throw new Error('Server returned empty file path');
        }

        // 挂载文件到当前消息的 extra.files
        try {
            const message = getCurrentMessage();
            if (message) {
                if (!message.extra || typeof message.extra !== 'object') {
                    message.extra = {};
                }
                if (!Array.isArray(message.extra.files)) {
                    message.extra.files = [];
                }
                message.extra.files.push({
                    url: filePath,
                    size: file.size,
                    name: file.name,
                    created: Date.now(),
                });
                console.log('[Attachment Queue] File mounted to message:', filePath);
            }
        } catch (e) {
            console.warn('[Attachment Queue] Warning: Could not mount file to current message:', e);
        }

        return filePath;
    } catch (error) {
        console.error('[Attachment Queue] Upload error:', error);
        throw error;
    }
}

/**
 * 简单的字符串哈希函数
 */
function getStringHash(str) {
    let hash = 0;
    if (!str || str.length === 0) return String(hash);
    for (let i = 0; i < str.length; i++) {
        const char = str.charCodeAt(i);
        hash = ((hash << 5) - hash) + char;
        hash = hash & hash; // Convert to 32bit integer
    }
    return String(Math.abs(hash));
}
async function processNext() {
    // 每次循环前检查是否仍在运行
    if (!isRunning) return;

    // 始终确保 uploadResult 从干净状态开始，一次只发一个附件
    if (typeof window.uploadResult !== 'undefined') {
        window.uploadResult = [];
    } else {
        window.uploadResult = [];
    }

    // 找到下一个待发送的文件（从第一个 pending 开始）
    const nextIndex = queue.findIndex(q => q.status === 'pending');

    if (nextIndex === -1) {
        // 没有待发送的文件了
        isRunning = false;
        toastr.success('队列全部完成！');
        updateStatusText();
        renderQueueList();
        return;
    }

    currentIndex = nextIndex;
    const item = queue[currentIndex];

    item.status = 'sending';
    renderQueueList();

    try {
        // --- 执行发送逻辑 ---
        await uploadAndSend(item);

        // --- 等待 AI 回复完成 ---
        // 我们不在这里死等，而是利用 EventSource 监听
        // 设置一个标志位，等待 generation_ended 事件来触发下一次 processNext
        // 这里只是为了保险，如果 60秒 没反应则超时
        // 真正的递归调用移交给 eventSource 监听器

    } catch (err) {
        console.error('[Attachment Queue] Error:', err);
        item.status = 'error';
        item.error = String(err);
        toastr.error(`文件 ${item.file.name} 发送失败`);

        // 如果出错，休息 1 秒继续下一个
        currentIndex++;
        setTimeout(() => {
            if (isRunning) void processNext();
        }, 1000);
        renderQueueList();
    }
}

function bindDropZoneEvents($root) {
    const $dropZone = $root.find('#attachment_queue_dropzone');
    const $fileInput = $root.find('#attachment_queue_file_input');

    // ... 保持原有逻辑 ...
    $dropZone.on('dragenter dragover', (e) => {
        e.preventDefault(); e.stopPropagation();
        $dropZone.addClass('attachment-queue-dropzone-hover');
    });
    $dropZone.on('dragleave dragend drop', (e) => {
        e.preventDefault(); e.stopPropagation();
        $dropZone.removeClass('attachment-queue-dropzone-hover');
    });
    $dropZone.on('drop', (e) => {
        const dt = e.originalEvent.dataTransfer;
        if (dt) addFilesToQueue(dt.files);
    });
    $dropZone.on('click', () => $fileInput.trigger('click'));
    $fileInput.on('change', (e) => {
        if (e.target.files.length) {
            addFilesToQueue(e.target.files);
            $fileInput.val('');
        }
    });
}

function bindControls($root) {
    const $start = $root.find('#attachment_queue_start');
    const $pause = $root.find('#attachment_queue_pause');
    const $clear = $root.find('#attachment_queue_clear');

    $start.on('click', () => {
        if (!queue.length) return toastr.info('队列为空');

        // 从第一个 pending 项重新开始/继续
        const nextIndex = queue.findIndex(q => q.status === 'pending');
        if (nextIndex === -1) {
            toastr.info('没有待发送的文件');
            return;
        }

        currentIndex = nextIndex;
        isRunning = true;
        updateStatusText();
        void processNext(); // 启动或继续
    });

    $pause.on('click', () => {
        isRunning = false;
        updateStatusText();
    });

    $clear.on('click', () => {
        queue = [];
        currentIndex = 0;
        isRunning = false;
        renderQueueList();
    });
}

async function initAttachmentQueueRightMenu() {
    // 创建右侧面板中的队列 Tab 内容
    if (!$(`#${RIGHT_MENU_ID}`).length) {
        const $scrollInner = $('#right-nav-panel .scrollableInner');
        if (!$scrollInner.length) return;

        const blockHtml = `
            <div id="${RIGHT_MENU_ID}" class="right_menu" style="display: none;">
                <div class="right-nav-header flex-container flexGap5">
                    <span class="attachment-queue-panel-title flex1">附件队列</span>
                </div>
                <div class="right-nav-content">
                    <div id="attachment_queue_dropzone" class="attachment-queue-dropzone">
                        拖拽文件到这里，或点击添加
                    </div>
                    <div class="attachment-queue-main flex-container flexGap8">
                        <div id="attachment_queue_list" class="attachment-queue-list flex1"></div>
                        <div id="attachment_queue_preview" class="attachment-queue-preview flex1"></div>
                    </div>
                </div>
                <div class="right-nav-footer flex-container flexGap5">
                    <button id="attachment_queue_add" type="button" class="menu_button menu_button_icon">
                        <i class="fa-solid fa-plus"></i>
                        <span>添加文件</span>
                    </button>
                    <button id="attachment_queue_clear" type="button" class="menu_button menu_button_icon menu_button-danger">
                        <i class="fa-solid fa-trash-can"></i>
                        <span>清空队列</span>
                    </button>
                    <span class="flex1"></span>
                    <span id="attachment_queue_status" class="attachment-queue-status"></span>
                </div>
                <input id="attachment_queue_file_input" type="file" multiple class="displayNone" />
            </div>`;

        $scrollInner.append(blockHtml);

        const $block = $(`#${RIGHT_MENU_ID}`);
        bindDropZoneEvents($block);
        bindControls($block);
        updateStatusText();

        // “添加文件”按钮触发文件选择
        $('#attachment_queue_add').on('click', () => {
            const inputEl = /** @type {HTMLInputElement | null} */ (document.getElementById('attachment_queue_file_input'));
            if (!inputEl) return;

            try {
                if (typeof inputEl.showPicker === 'function') {
                    inputEl.showPicker();
                } else {
                    inputEl.click();
                }
            } catch {
                inputEl.click();
            }
        });

        // 注册 AI 回复结束事件，驱动队列继续
        eventSource.on(event_types.GENERATION_ENDED, () => {
            if (!isRunning) return;

            if (queue[currentIndex] && queue[currentIndex].status === 'sending') {
                queue[currentIndex].status = 'done';
                currentIndex++;
                renderQueueList();

                setTimeout(() => {
                    if (isRunning) void processNext();
                }, 1000);
            }
        });
    }

    // 在角色管理按钮行中增加一个“附件队列”按钮
    if (!$('#attachment_queue_tab_button').length) {
        const $btnContainer = $('#rm_buttons_container');
        if ($btnContainer.length) {
            const btnHtml = `
                <div id="attachment_queue_tab_button" class="menu_button fa-solid fa-layer-group" title="附件队列"></div>`;
            $btnContainer.append(btnHtml);

            $('#attachment_queue_tab_button').on('click', async () => {
                await initAttachmentQueueRightMenu();
                selectRightMenuWithAnimation(RIGHT_MENU_ID);
            });
        }
    }

    // 顶部图标：打开右侧面板并切换到队列 Tab
    if (!$('#attachment_queue_icon').length) {
        const iconHtml = `
            <div id="attachment_queue_icon" class="drawer">
                <div class="drawer-toggle">
                    <div class="drawer-icon fa-solid fa-layer-group fa-fw" title="附件队列" data-i18n="[title]Attachment Queue"></div>
                </div>
            </div>`;

        const $backgrounds = $('#backgrounds-button');
        const $extensions = $('#extensions-settings-button');

        if ($backgrounds.length) {
            $(iconHtml).insertAfter($backgrounds);
        } else if ($extensions.length) {
            $(iconHtml).insertBefore($extensions);
        } else {
            $('#top-settings-holder').append(iconHtml);
        }

        $('#attachment_queue_icon .drawer-toggle').on('click', async function () {
            // 打开右侧总面板
            const rightNavToggle = document.getElementById('unimportantYes');
            if (rightNavToggle) {
                await doNavbarIconClick.call(rightNavToggle);
            }

            await initAttachmentQueueRightMenu();
            selectRightMenuWithAnimation(RIGHT_MENU_ID);
        });
    }
}

function initAttachmentQueueSmartControls() {
    const $send = $('#send_but');
    if (!$send.length) return;

    if (!$('#attachment_queue_play').length) {
        const controlsHtml = `
            <div id="attachment_queue_play" class="fa-solid fa-play interactable displayNone" title="开始附件队列"></div>
            <div id="attachment_queue_pause" class="fa-solid fa-pause interactable displayNone" title="暂停附件队列"></div>`;

        $(controlsHtml).insertAfter($send);

        $('#attachment_queue_play').on('click', () => {
            if (!queue.length) {
                toastr.info('队列为空');
                updateSmartControlsVisibility();
                return;
            }

            const nextIndex = queue.findIndex(q => q.status === 'pending');
            if (nextIndex === -1) {
                toastr.info('没有待发送的文件');
                updateSmartControlsVisibility();
                return;
            }

            currentIndex = nextIndex;
            isRunning = true;
            updateStatusText();
            updateSmartControlsVisibility();
            void processNext();
        });

        $('#attachment_queue_pause').on('click', () => {
            isRunning = false;
            updateStatusText();
            updateSmartControlsVisibility();
        });
    }

    updateSmartControlsVisibility();
}

function updateSmartControlsVisibility() {
    const $play = $('#attachment_queue_play');
    const $pause = $('#attachment_queue_pause');
    if (!$play.length || !$pause.length) return;

    if (queue.length === 0) {
        $play.addClass('displayNone');
        $pause.addClass('displayNone');
        return;
    }

    if (isRunning) {
        $play.addClass('displayNone');
        $pause.removeClass('displayNone');
    } else {
        $play.removeClass('displayNone');
        $pause.addClass('displayNone');
    }
}

function initAttachmentQueueWandButton() {
    const $container = $('#attach_file_wand_container');
    if (!$container.length) return;

    if ($('#attachment_queue_wand_button').length) {
        return;
    }

    const html = `
        <div id="attachment_queue_wand_button" class="list-group-item flex-container flexGap5">
            <div class="fa-fw fa-solid fa-layer-group extensionsMenuExtensionButton"></div>
            <span>附加文件队列</span>
        </div>`;

    const $attachButton = $container.find('#attachFile');
    if ($attachButton.length) {
        $attachButton.after(html);
    } else {
        $container.prepend(html);
    }

    $('#attachment_queue_wand_button').on('click', async () => {
        await initAttachmentQueueDrawer();

        const inputEl = /** @type {HTMLInputElement | null} */ (document.getElementById('attachment_queue_file_input'));
        if (!inputEl) return;

        try {
            if (typeof inputEl.showPicker === 'function') {
                inputEl.showPicker();
            } else {
                inputEl.click();
            }
        } catch {
            inputEl.click();
        }

        // 选完文件后，addFilesToQueue 会自动展开面板；这里保证至少是显示的
        $('#attachment_queue_panel').show();
    });
}

jQuery(() => {
    if (typeof eventSource === 'undefined' || !event_types) {
        console.error('[Attachment Queue] eventSource not available');
        return;
    }

    eventSource.on(event_types.APP_READY, () => {
        void initAttachmentQueueRightMenu();
        initAttachmentQueueSmartControls();
        initAttachmentQueueWandButton();

        // 重写角色管理抽屉图标行为：
        // - 正常情况下保持 ST 原生的开关逻辑
        // - 当右侧已打开且当前显示的是队列时，点击只切回角色列表，而不收起抽屉
        const $rightNavToggle = $('#unimportantYes'); // drawer-toggle 容器
        if ($rightNavToggle.length) {
            $rightNavToggle.off('click.stAttachmentQueue');

            $rightNavToggle.off('click').on('click', async function () {
                const $drawer = $('#right-nav-panel');
                const isOpen = $drawer.hasClass('openDrawer');
                const isQueueVisible = $(`#${RIGHT_MENU_ID}`).is(':visible');

                if (isOpen && isQueueVisible) {
                    // 抽屉已打开且正在看队列：只切换到角色列表，不关闭抽屉
                    selectRightMenuWithAnimation('rm_characters_block');
                    return;
                }

                // 其它情况：沿用原生的开关逻辑
                await doNavbarIconClick.call(this);

                const nowOpen = $drawer.hasClass('openDrawer');
                if (nowOpen) {
                    selectRightMenuWithAnimation('rm_characters_block');
                }
            });
        }
    });
});

/**
 * 绑定拖拽排序事件
 * @param {JQuery} $row
 * @param {string} id
 */
function bindDragAndDropEvents($row, id) {
    $row.on('dragstart', (e) => {
        dragSourceId = id;
        $row.addClass('attachment-queue-item-dragging');

        const dt = e.originalEvent?.dataTransfer;
        if (dt) {
            dt.effectAllowed = 'move';
            dt.setData('text/plain', id);
        }
    });

    $row.on('dragover', (e) => {
        e.preventDefault();
        const dt = e.originalEvent?.dataTransfer;
        if (dt) {
            dt.dropEffect = 'move';
        }
        $row.addClass('attachment-queue-item-dragover');
    });

    $row.on('dragleave', () => {
        $row.removeClass('attachment-queue-item-dragover');
    });

    $row.on('dragend', () => {
        $row.removeClass('attachment-queue-item-dragging attachment-queue-item-dragover');
        dragSourceId = null;
    });

    $row.on('drop', (e) => {
        e.preventDefault();
        $row.removeClass('attachment-queue-item-dragover');

        const dt = e.originalEvent?.dataTransfer;
        const sourceId = dt?.getData('text/plain') || dragSourceId;
        const targetId = id;

        if (!sourceId || !targetId || sourceId === targetId) {
            return;
        }

        reorderQueueById(sourceId, targetId);
        renderQueueList();
    });
}

/**
 * 根据拖拽结果重新排序队列
 * @param {string} sourceId
 * @param {string} targetId
 */
function reorderQueueById(sourceId, targetId) {
    const fromIndex = queue.findIndex(q => q.id === sourceId);
    const toIndex = queue.findIndex(q => q.id === targetId);

    if (fromIndex === -1 || toIndex === -1 || fromIndex === toIndex) {
        return;
    }

    const [moved] = queue.splice(fromIndex, 1);
    queue.splice(toIndex, 0, moved);

    // 修正当前索引，避免越界
    if (currentIndex === fromIndex) {
        currentIndex = toIndex;
    } else if (fromIndex < currentIndex && toIndex >= currentIndex) {
        currentIndex -= 1;
    } else if (fromIndex > currentIndex && toIndex <= currentIndex) {
        currentIndex += 1;
    }
}
